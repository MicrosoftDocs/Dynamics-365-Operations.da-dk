---
title: Forbedre planlægningsprogrammets ydeevne
description: Dette emne giver oplysninger om planlægningsprogrammet, og hvordan ydeevnen kan forbedres.
author: ChristianRytt
manager: tfehr
ms.date: 09/03/2020
ms.topic: article
ms.prod: ''
ms.service: dynamics-ax-applications
ms.technology: ''
ms.search.form: ''
audience: Application User
ms.reviewer: kamaybac
ms.custom: 19311
ms.assetid: 5ffb1486-2e08-4cdc-bd34-b47ae795ef0f
ms.search.region: Global
ms.search.industry: ''
ms.author: kamaybac
ms.search.validFrom: 2020-09-03
ms.dyn365.ops.version: ''
ms.openlocfilehash: 0b55d0e94b40adf232e6b5cc3a9fb422e4539340
ms.sourcegitcommit: eaf330dbee1db96c20d5ac479f007747bea079eb
ms.translationtype: HT
ms.contentlocale: da-DK
ms.lasthandoff: 02/15/2021
ms.locfileid: "5246759"
---
# <a name="improve-scheduling-engine-performance"></a><span data-ttu-id="81977-103">Forbedre planlægningsprogrammets ydeevne</span><span class="sxs-lookup"><span data-stu-id="81977-103">Improve scheduling engine performance</span></span>

[!include [banner](../includes/banner.md)]

<span data-ttu-id="81977-104">Ressourceplanlægningsprogrammet bruges ved planlægning af ruter for planlagte og frigivne produktionsordrer.</span><span class="sxs-lookup"><span data-stu-id="81977-104">The resource scheduling engine is used when scheduling routes for planned and released production orders.</span></span> <span data-ttu-id="81977-105">Programmet blev oprindeligt frigivet som en del af Dynamics AX 2012 og har gennemgået flere forbedringer siden frigivelsen.</span><span class="sxs-lookup"><span data-stu-id="81977-105">The engine was originally released as part of Dynamics AX 2012 and has gone through several improvements since its release.</span></span>

<span data-ttu-id="81977-106">[Problemet med jobbet til produktionsplanlægning](https://en.wikipedia.org/wiki/Job_shop_scheduling) er et særdeles komplekst kombinationsproblem, hvor løsningstiden vokser eksponentielt med antallet af beslutningsvariabler.</span><span class="sxs-lookup"><span data-stu-id="81977-106">The [job shop scheduling problem](https://en.wikipedia.org/wiki/Job_shop_scheduling) is an extremely complex combinatorial problem where solution time grows exponentially with the number of decision variables.</span></span> <span data-ttu-id="81977-107">Ofte konfigurerer kunder produktionsruter og relaterede data på en måde, der resulterer i et planlægningsproblem, der ikke kan løses i et rimeligt tidsrum selv på den mest moderne hardware.</span><span class="sxs-lookup"><span data-stu-id="81977-107">Oftentimes, customers set up production routes and related data in a way that results in a scheduling problem that can't be solved in reasonable time even on the most modern hardware.</span></span> <span data-ttu-id="81977-108">Dette emne vil hjælpe dig med at forstå planlægningsprogrammet, og hvordan en bestemt opsætning kan have indflydelse på ydeevnen.</span><span class="sxs-lookup"><span data-stu-id="81977-108">This topic will help you understand the scheduling engine and how a specific setup can have influence on the performance.</span></span>

<span data-ttu-id="81977-109">Når det drejer sig om at forbedre planlægningens ydeevne, anbefaler de generelle retningslinjer at reducere kompleksiteten af det problem, du skal løse.</span><span class="sxs-lookup"><span data-stu-id="81977-109">When it comes to improving the performance of the scheduling, general guidelines recommend reducing the complexity of the problem the engine needs to solve.</span></span> <span data-ttu-id="81977-110">Nogle af de vigtigste faktorer, der kan påvirke ydeevnen, omfatter:</span><span class="sxs-lookup"><span data-stu-id="81977-110">Some of the main factors that can affect performance include:</span></span>

- <span data-ttu-id="81977-111">Ruter med mange handlinger</span><span class="sxs-lookup"><span data-stu-id="81977-111">Routes with many operations</span></span>
- <span data-ttu-id="81977-112">Ruter med parallelle handlinger</span><span class="sxs-lookup"><span data-stu-id="81977-112">Routes with parallel operations</span></span>
- <span data-ttu-id="81977-113">Operationer med et antal ressourcer, der er større end én</span><span class="sxs-lookup"><span data-stu-id="81977-113">Operations with quantity of resources higher than one</span></span>
- <span data-ttu-id="81977-114">Operationer med mange relevante ressourcer</span><span class="sxs-lookup"><span data-stu-id="81977-114">Operations with many applicable resources</span></span>
- <span data-ttu-id="81977-115">Brug af hårde links</span><span class="sxs-lookup"><span data-stu-id="81977-115">Use of hard links</span></span>
- <span data-ttu-id="81977-116">Brug af kapacitetsbegrænsning</span><span class="sxs-lookup"><span data-stu-id="81977-116">Use of finite capacity</span></span>
- <span data-ttu-id="81977-117">Antallet af forskellige kalendere, der bruges</span><span class="sxs-lookup"><span data-stu-id="81977-117">The number of different calendars used</span></span>
- <span data-ttu-id="81977-118">Antallet af arbejdstidsrubrikker pr. dag i kalenderen</span><span class="sxs-lookup"><span data-stu-id="81977-118">The number of working time slots per day in the calendar</span></span>
- <span data-ttu-id="81977-119">Rutens samlede varighed</span><span class="sxs-lookup"><span data-stu-id="81977-119">Total duration of the route</span></span>
- <span data-ttu-id="81977-120">Kørsel af flere planlægningsprogrammer parallelt</span><span class="sxs-lookup"><span data-stu-id="81977-120">Running multiple scheduling engines in parallel</span></span>

## <a name="overview-of-basic-scheduling-flow"></a><span data-ttu-id="81977-121">Oversigt over grundlæggende planlægningsflow</span><span class="sxs-lookup"><span data-stu-id="81977-121">Overview of basic scheduling flow</span></span>

<span data-ttu-id="81977-122">For at forstå, hvordan en bestemt opsætning kan påvirke ydeevnen, er det vigtigt at forstå noget om, hvordan processen flyder, både inde i programmet og i X++-kode, der omgiver det.</span><span class="sxs-lookup"><span data-stu-id="81977-122">To understand how a given setup can affect performance, it is important to understand something about how the process flows, both inside the engine and in the X++ code that surrounds it.</span></span>

<span data-ttu-id="81977-123">Den grundlæggende proces til planlægning af en ordre består af tre hovedtrin:</span><span class="sxs-lookup"><span data-stu-id="81977-123">The basic process of scheduling an order consists of three main steps:</span></span>

- <span data-ttu-id="81977-124">**Indlæsning af data** – Her omdannes X++-datamodellerne til programmets interne datamodel i form af job og begrænsninger.</span><span class="sxs-lookup"><span data-stu-id="81977-124">**Loading data** – Here, the X++ data models are transformed into the engine's internal data model in the form of jobs and constraints.</span></span>
- <span data-ttu-id="81977-125">**Planlægning** – Dette er den overordnede kilde til planlægning, der behandler de angivne modeller og begrænsninger, og som genererer et resultat.</span><span class="sxs-lookup"><span data-stu-id="81977-125">**Scheduling** – This is the main source for scheduling that processes the given model and constraints, and generates a result.</span></span> <span data-ttu-id="81977-126">Under denne proces vil programmet anmode om oplysninger om arbejdstiden og eksisterende kapacitetsreservationer fra X++ efter behov.</span><span class="sxs-lookup"><span data-stu-id="81977-126">During this process, the engine will request working time information and existing capacity reservations from X++ as needed.</span></span>
- <span data-ttu-id="81977-127">**Gem data** – Programresultatet i form af jobkapacitetsreservationspladser behandles af X++-kode for at gemme kapacitetsreservationer og opdatere start- og sluttidspunkter for jobbene/operationen/ordren.</span><span class="sxs-lookup"><span data-stu-id="81977-127">**Save data** – The engine result in the form of job capacity reservation slots is processed by X++ code to save capacity reservations and update the start and end times of the jobs/operation/order.</span></span>

## <a name="load-data-into-the-engine"></a><span data-ttu-id="81977-128">Indlæse data i programmet</span><span class="sxs-lookup"><span data-stu-id="81977-128">Load data into the engine</span></span>

<span data-ttu-id="81977-129">Planlægningsprogrammet har en mere abstrakt datamodel end Supply Chain Management-databasen, fordi det er bygget som et generisk program, der kan håndtere forskellige datakilder.</span><span class="sxs-lookup"><span data-stu-id="81977-129">The scheduling engine has a more abstract data model than the Supply Chain Management database because it has been built as a generic engine that can handle different sources of data.</span></span> <span data-ttu-id="81977-130">Koncepterne for rute, sekundære operationer og kørselstid skal "oversættes" til det generiske job og den begrænsningsmodel, som programmet viser.</span><span class="sxs-lookup"><span data-stu-id="81977-130">The concepts of route, secondary operations, and run time need to be "translated" into the generic job and constraint model that the engine exposes.</span></span> <span data-ttu-id="81977-131">Logikken for opbygning af modellen har en stor mængde forretningslogik og varierer alt efter kildedataene.</span><span class="sxs-lookup"><span data-stu-id="81977-131">The logic for building the model has a significant amount of business logic to it and is different depending on the source data.</span></span> <span data-ttu-id="81977-132">Den ansvarlige X++-klasse er `WrkCtrScheduler` og har afledte klasser for produktionsordreforslag, frigivne produktionsordrer og projektprognoser.</span><span class="sxs-lookup"><span data-stu-id="81977-132">The responsible X++ class is `WrkCtrScheduler` and it has derived classes for planned production orders, released production orders, and project forecasts.</span></span>

<span data-ttu-id="81977-133">Overvej f.eks. en rute, der vises i følgende tabel og billede, som ser relativt enkel ud.</span><span class="sxs-lookup"><span data-stu-id="81977-133">As an example, consider a route shown in the following table and image, which seems relatively simple.</span></span>

| <span data-ttu-id="81977-134">Opr.</span><span class="sxs-lookup"><span data-stu-id="81977-134">Oper.</span></span> <span data-ttu-id="81977-135">Nr.</span><span class="sxs-lookup"><span data-stu-id="81977-135">No.</span></span> | <span data-ttu-id="81977-136">Prioritet</span><span class="sxs-lookup"><span data-stu-id="81977-136">Priority</span></span> | <span data-ttu-id="81977-137">Opstillingstid</span><span class="sxs-lookup"><span data-stu-id="81977-137">Setup time</span></span> | <span data-ttu-id="81977-138">Procestid</span><span class="sxs-lookup"><span data-stu-id="81977-138">Run time</span></span> | <span data-ttu-id="81977-139">Køventetid efter</span><span class="sxs-lookup"><span data-stu-id="81977-139">Queue time after</span></span> | <span data-ttu-id="81977-140">Antal ressourcer</span><span class="sxs-lookup"><span data-stu-id="81977-140">Quantity of resources</span></span> | <span data-ttu-id="81977-141">Næste</span><span class="sxs-lookup"><span data-stu-id="81977-141">Next</span></span> |
| --- | --- | --- | --- | --- | --- | --- |
| <span data-ttu-id="81977-142">10</span><span class="sxs-lookup"><span data-stu-id="81977-142">10</span></span> | <span data-ttu-id="81977-143">Primær</span><span class="sxs-lookup"><span data-stu-id="81977-143">Primary</span></span> | <span data-ttu-id="81977-144">1.00</span><span class="sxs-lookup"><span data-stu-id="81977-144">1.00</span></span> | <span data-ttu-id="81977-145">2.00</span><span class="sxs-lookup"><span data-stu-id="81977-145">2.00</span></span> | | <span data-ttu-id="81977-146">1</span><span class="sxs-lookup"><span data-stu-id="81977-146">1</span></span> | <span data-ttu-id="81977-147">20</span><span class="sxs-lookup"><span data-stu-id="81977-147">20</span></span> |
| <span data-ttu-id="81977-148">10</span><span class="sxs-lookup"><span data-stu-id="81977-148">10</span></span> | <span data-ttu-id="81977-149">Sekundær&nbsp;1</span><span class="sxs-lookup"><span data-stu-id="81977-149">Secondary&nbsp;1</span></span> | | | | <span data-ttu-id="81977-150">1</span><span class="sxs-lookup"><span data-stu-id="81977-150">1</span></span> | <span data-ttu-id="81977-151">20</span><span class="sxs-lookup"><span data-stu-id="81977-151">20</span></span> |
| <span data-ttu-id="81977-152">20</span><span class="sxs-lookup"><span data-stu-id="81977-152">20</span></span> | <span data-ttu-id="81977-153">Primær</span><span class="sxs-lookup"><span data-stu-id="81977-153">Primary</span></span> | | <span data-ttu-id="81977-154">3.00</span><span class="sxs-lookup"><span data-stu-id="81977-154">3.00</span></span> | <span data-ttu-id="81977-155">1.00</span><span class="sxs-lookup"><span data-stu-id="81977-155">1.00</span></span> | <span data-ttu-id="81977-156">3</span><span class="sxs-lookup"><span data-stu-id="81977-156">3</span></span> | <span data-ttu-id="81977-157">0</span><span class="sxs-lookup"><span data-stu-id="81977-157">0</span></span> |

<span data-ttu-id="81977-158">![Eksempel på rutediagram](media/scheduling-engine-route.png "Eksempel på rutediagram")</span><span class="sxs-lookup"><span data-stu-id="81977-158">![Example rout diagram](media/scheduling-engine-route.png "Example rout diagram")</span></span>

<span data-ttu-id="81977-159">Når du sender dette til programmet, opdeles det i otte job som vist i følgende illustration (vælg billedet for at forstørre det).</span><span class="sxs-lookup"><span data-stu-id="81977-159">When sending this to the engine, it is split out into eight jobs, as shown in the following illustration (select the image to enlarge it).</span></span>

<span data-ttu-id="81977-160">[![Planlægning af programjob](media/scheduling-engine-jobs.png "Planlægning af programjob")](media/scheduling-engine-jobs-large.png)</span><span class="sxs-lookup"><span data-stu-id="81977-160">[![Scheduling engine jobs](media/scheduling-engine-jobs.png "Scheduling engine jobs")](media/scheduling-engine-jobs-large.png)</span></span>

<span data-ttu-id="81977-161">Standardforbindelsen mellem to job er `FinishStart`, hvilket betyder, at sluttidspunktet for ét job skal ligge før starttidspunktet for et andet job.</span><span class="sxs-lookup"><span data-stu-id="81977-161">The standard link between two jobs is `FinishStart`, meaning that the end time of one job must be before the start time of another job.</span></span> <span data-ttu-id="81977-162">Da opsætningen skal udføres af den samme ressource, der senere udfører processen, vil der være `OnSameResource`-begrænsninger mellem dem.</span><span class="sxs-lookup"><span data-stu-id="81977-162">Because the setup must be performed by the same resource that will later do the process, there are `OnSameResource` constraints between them.</span></span> <span data-ttu-id="81977-163">Mellem jobbene for primær og sekundær operation for 10 er der `StartStart`- og `FinishFinish`-links, hvilket betyder, at jobbene både skal starte og slutte på samme tid, og der er `NotOnSameResource`-begrænsninger, som vil forhindre den samme ressource til primær og sekundær.</span><span class="sxs-lookup"><span data-stu-id="81977-163">Between the jobs for primary and secondary operation for 10, there are `StartStart` and `FinishFinish` links, which means that the jobs must both start and end at the same time, and there are `NotOnSameResource` constraints, which will prevent the same resource for primary and secondary.</span></span>

<span data-ttu-id="81977-164">Ved operation 20, hvor antallet af ressourcer er angivet til 3, er procesjobbet opdelt i tre forskellige job, hvor alle job skal køres på nøjagtigt samme tidspunkt.</span><span class="sxs-lookup"><span data-stu-id="81977-164">For operation 20, where the quantity of resources has been set to 3, the process job has been split into three distinct jobs where all the jobs must run at the exact same time.</span></span>
<span data-ttu-id="81977-165">I dette tilfælde er rutegruppen konfigureret til ikke at reservere kapacitet for kø efter tider, hvilket betyder, at der kun er ét job for køen efter.</span><span class="sxs-lookup"><span data-stu-id="81977-165">In this case, the route group has been set up to not reserve capacity for queue after times, which is why there is only a single job for the queue after.</span></span>

<span data-ttu-id="81977-166">Planlægningsprogrammet forstår kun begreberne for job og har intet begreb om operationer.</span><span class="sxs-lookup"><span data-stu-id="81977-166">The scheduling engine only understands the concepts of jobs and has no notion of operations.</span></span> <span data-ttu-id="81977-167">Det betyder, at når operationsplanlægningen udføres, opdeles operationerne også i job, selvom de ikke bevares i databasen.</span><span class="sxs-lookup"><span data-stu-id="81977-167">This means that when doing operation scheduling, the operations are also split into jobs, although these will not be persisted in the database.</span></span>

<span data-ttu-id="81977-168">For hvert job definerer vi også jobkapacitetskravet (antal påkrævede sekunder).</span><span class="sxs-lookup"><span data-stu-id="81977-168">For each job, we will also define what the job capacity requirement is (the number of seconds required).</span></span> <span data-ttu-id="81977-169">Afhængigt af, hvordan ressourcekravene er defineret, kan vi også for hvert job sende en liste over alle de potentielle relevante ressourcer, som jobbet kunne køre på, og hvad kapacitetskravet er for den pågældende ressource.</span><span class="sxs-lookup"><span data-stu-id="81977-169">Depending on how the resource requirements have been defined, we may also, for each job, send a list of all the potential applicable resources that the job could run on and what the capacity requirement is for that specific resource.</span></span> <span data-ttu-id="81977-170">Selvom listen over relevante ressourcer sendes, når modellen bygges, skal programmet stadig sikre, at ressourcetildelingen er gyldig for hele varigheden af jobbet.</span><span class="sxs-lookup"><span data-stu-id="81977-170">Even though the list of applicable resources is sent when building the model, the engine will still need to ensure that the resource assignment is actually valid for the entire job duration.</span></span>

## <a name="scheduling-engine-internals"></a><span data-ttu-id="81977-171">Planlægning af programmets indre</span><span class="sxs-lookup"><span data-stu-id="81977-171">Scheduling engine internals</span></span>

### <a name="scheduling-engine-interface"></a><span data-ttu-id="81977-172">Planlægning af programmets grænseflade</span><span class="sxs-lookup"><span data-stu-id="81977-172">Scheduling engine interface</span></span>

<span data-ttu-id="81977-173">Hvis du vil have en ide om, hvordan programmets indre fungerer, er det bedst at se på de funktioner, det viser eksternt.</span><span class="sxs-lookup"><span data-stu-id="81977-173">To get an idea of how the engine works internally, it is best to look at the functionality it exposes externally.</span></span> <span data-ttu-id="81977-174">I X++ er hovedgrænsefladen `WrkCtrSchedulerEngineInterface`.</span><span class="sxs-lookup"><span data-stu-id="81977-174">In X++, the main interface is `WrkCtrSchedulerEngineInterface`.</span></span> <span data-ttu-id="81977-175">Den indeholder de metoder, der er beskrevet i følgende underafsnit.</span><span class="sxs-lookup"><span data-stu-id="81977-175">It has the methods described in the following subsections.</span></span>

#### <a name="general-engine"></a><span data-ttu-id="81977-176">Generisk program</span><span class="sxs-lookup"><span data-stu-id="81977-176">General engine</span></span>

| <span data-ttu-id="81977-177">**metode**</span><span class="sxs-lookup"><span data-stu-id="81977-177">**Method**</span></span> | <span data-ttu-id="81977-178">**Formål**</span><span class="sxs-lookup"><span data-stu-id="81977-178">**Purpose**</span></span> |
| --- | --- |
| `run` | <span data-ttu-id="81977-179">Planlægger alle indlæste job og returnerer fejlkoden.</span><span class="sxs-lookup"><span data-stu-id="81977-179">Schedules all loaded jobs and returns the error code.</span></span> |
| `getJobSchedulingSequenceResult` | <span data-ttu-id="81977-180">Henter planlægningsresultatet og det første fejljob for den sekvens, der identificeres af et bestemt job.</span><span class="sxs-lookup"><span data-stu-id="81977-180">Gets the scheduling result and the first error job for the sequence identified by a specific job.</span></span> |
| `validateJobCapacityReservations` | <span data-ttu-id="81977-181">Validerer kapacitetsreservationerne for alle job, der er gemt af programmet.</span><span class="sxs-lookup"><span data-stu-id="81977-181">Validates the capacity reservations for all the jobs stored by the engine.</span></span> |
| `setReservationsTimeStamp` | <span data-ttu-id="81977-182">Sender et tidsstempel til programmet, der er angivet på alle nye kapacitetsreservationer for de planlagte job i programmets cache.</span><span class="sxs-lookup"><span data-stu-id="81977-182">Sends a timestamp to the engine set on all new capacity reservations for the scheduled jobs in the cache of the engine.</span></span> |
| `addPropertyToGroupAggregation` | <span data-ttu-id="81977-183">Føjer et egenskabspræfiks til det sæt egenskaber, der bruges, når kapaciteten samles.</span><span class="sxs-lookup"><span data-stu-id="81977-183">Adds a property prefix to the set of properties used when capacity is aggregated.</span></span> |
| `addResource` | <span data-ttu-id="81977-184">Føjer en ressource til planlægningsprogrammets ressourcepulje.</span><span class="sxs-lookup"><span data-stu-id="81977-184">Adds a resource to the scheduling engine resource pool.</span></span> |
| `addResourceGroup` | <span data-ttu-id="81977-185">Føjer en ressourcegruppe til planlægningsprogrammets ressourcegruppepulje.</span><span class="sxs-lookup"><span data-stu-id="81977-185">Adds a resource group to the scheduling engine resource group pool.</span></span> |
| `addResourceGroupMembership` | <span data-ttu-id="81977-186">Føjer en ressource som medlem til en ressourcegruppe.</span><span class="sxs-lookup"><span data-stu-id="81977-186">Adds a resource as a member to a resource group.</span></span> |
| `addOptimizationGoal` | <span data-ttu-id="81977-187">Tilføjer et mål for planlægningsoptimering (varighed eller prioritet).</span><span class="sxs-lookup"><span data-stu-id="81977-187">Adds a scheduling optimization goal (duration or priority).</span></span> |

#### <a name="individual-jobs"></a><span data-ttu-id="81977-188">Individuelle job</span><span class="sxs-lookup"><span data-stu-id="81977-188">Individual jobs</span></span>

| <span data-ttu-id="81977-189">**metode**</span><span class="sxs-lookup"><span data-stu-id="81977-189">**Method**</span></span> | <span data-ttu-id="81977-190">**Formål**</span><span class="sxs-lookup"><span data-stu-id="81977-190">**Purpose**</span></span> |
| --- | --- |
| `addJobInfo` | <span data-ttu-id="81977-191">Tilføjer en post med joboplysninger, der oplyser programmet om et job, der skal planlægges.</span><span class="sxs-lookup"><span data-stu-id="81977-191">Adds a job information record that informs the engine about a job that should be scheduled.</span></span> |
| `addConstraintJobEndsAt` | <span data-ttu-id="81977-192">Tilføjer en begrænsning, hvor et job skal slutte på en bestemt dato og et bestemt tidspunkt.</span><span class="sxs-lookup"><span data-stu-id="81977-192">Adds a constraint that a job should end at a specified date and time.</span></span> |
| `addConstraintJobStartsAt` | <span data-ttu-id="81977-193">Tilføjer en begrænsning, hvor et job skal starte på en bestemt dato og et bestemt tidspunkt.</span><span class="sxs-lookup"><span data-stu-id="81977-193">Adds a constraint that a job should start at a specified date and time.</span></span> |
| `addConstraintMaxJobDays` | <span data-ttu-id="81977-194">Definerer en begrænsning, hvor et job kan spænde over et angivet maksimalt antal dage.</span><span class="sxs-lookup"><span data-stu-id="81977-194">Defines the constraint that a job can span over a specified maximal number of days.</span></span> |
| `addConstraintResourceRequirement` | <span data-ttu-id="81977-195">Tilføjer en begrænsning, hvor jobbet skal planlægges på en bestemt ressource.</span><span class="sxs-lookup"><span data-stu-id="81977-195">Adds the constraint that the job must be scheduled on a specific resource.</span></span> |
| `addJobBindPriority` | <span data-ttu-id="81977-196">Tilføjer en prioritet af jobbinding for et par (job, begrænsningsniveau).</span><span class="sxs-lookup"><span data-stu-id="81977-196">Adds a job bind priority for a (job, constraint level) pair.</span></span> <span data-ttu-id="81977-197">En højere prioritetsværdi betyder, at jobvariablerne bindes tidligere.</span><span class="sxs-lookup"><span data-stu-id="81977-197">A higher priority value means the job variables will be bound earlier.</span></span> <span data-ttu-id="81977-198">Jobbet behandles før job med lavere prioritetsværdi i samme sekvens.</span><span class="sxs-lookup"><span data-stu-id="81977-198">The job will be processed before jobs with lower priority value in the same sequence.</span></span> |
| `addJobCapacity` | <span data-ttu-id="81977-199">Tilføjer kapacitetsbelastningsoplysninger for et job (som den påkrævede jobkørselstid) uafhængigt af, hvilken ressource jobbet kører på.</span><span class="sxs-lookup"><span data-stu-id="81977-199">Adds capacity load information for a job (like the required job runtime) independent on which resource the job runs on.</span></span> |
| `addJobResourceCapacity` | <span data-ttu-id="81977-200">Føjer en ressource til det sæt ressourcer, der kan bruges til at udføre et job, og angiver den kapacitet, der kræves, når der køres på den pågældende ressource.</span><span class="sxs-lookup"><span data-stu-id="81977-200">Adds a resource to the set of resources that may be used to perform a job, and states the capacity required when running on that resource.</span></span> |
| `addJobGoal` | <span data-ttu-id="81977-201">Tilføjer oplysninger om jobmål for et specifikt begrænsningsniveau (tidligste sluttidspunkt eller seneste starttidspunkt).</span><span class="sxs-lookup"><span data-stu-id="81977-201">Adds job goal information for a specific constraint level (earliest end time or latest start time).</span></span> |
| `addJobResourcePriority` | <span data-ttu-id="81977-202">Tilføjer den prioritet, der skal bruges, når et job planlægges på en ressource.</span><span class="sxs-lookup"><span data-stu-id="81977-202">Adds the priority to use when a job is scheduled on a resource.</span></span> |
| `addJobResourceRuntime` | <span data-ttu-id="81977-203">Angiver en jobtid, der er afhængig af den ressource, som jobbet planlægges på.</span><span class="sxs-lookup"><span data-stu-id="81977-203">Specifies a job time that is dependent of the resource the job will be scheduled on.</span></span> |
| `addJobRuntime` | <span data-ttu-id="81977-204">Angiver en jobtid, der er uafhængig af den ressource, som jobbet planlægges på.</span><span class="sxs-lookup"><span data-stu-id="81977-204">Specifies a job time that is independent of the resource on which the job will be scheduled.</span></span> |
| `scheduleJobOnResourceGroup` | <span data-ttu-id="81977-205">Markerer et job til planlægning på ressourcegruppeniveau.</span><span class="sxs-lookup"><span data-stu-id="81977-205">Marks a job for scheduling on the resource group level.</span></span> |
| `setJobResourcePreemptionAllowed` | <span data-ttu-id="81977-206">Angiver, om jobforkøbsret er tilladt for et job på en ressource (hvis programmet har tilladelse til at planlægge jobbet i ikke-sammenhængende kapacitetspladser).</span><span class="sxs-lookup"><span data-stu-id="81977-206">Sets whether preemption is allowed for a job on a resource (if engine is allowed to schedule the job in noncontiguous capacity slots).</span></span> |
| `setRequiredNumberOfResources` | <span data-ttu-id="81977-207">Angiver det antal ressourcer, der kræves for at planlægge et job (kun til operationsplanlægning).</span><span class="sxs-lookup"><span data-stu-id="81977-207">Sets the number of resources required to schedule a job (only for operations scheduling).</span></span> |

#### <a name="constraints-between-jobs"></a><span data-ttu-id="81977-208">Begrænsninger mellem job</span><span class="sxs-lookup"><span data-stu-id="81977-208">Constraints between jobs</span></span>

| <span data-ttu-id="81977-209">**metode**</span><span class="sxs-lookup"><span data-stu-id="81977-209">**Method**</span></span> | <span data-ttu-id="81977-210">**Formål**</span><span class="sxs-lookup"><span data-stu-id="81977-210">**Purpose**</span></span> |
| --- | --- |
| `addJobLink` | <span data-ttu-id="81977-211">Tilføjer et link (som f.eks. slut\>start) mellem to job.</span><span class="sxs-lookup"><span data-stu-id="81977-211">Adds a link (such as finish\>start) between two jobs.</span></span> |
| `addConstraintEndsDelayed` | <span data-ttu-id="81977-212">Definerer den begrænsning, at et job ikke må slutte, før et andet job afsluttes plus en vis forsinkelsestid.</span><span class="sxs-lookup"><span data-stu-id="81977-212">Defines the constraint that a job cannot end before another jobs end plus some delay time.</span></span> |
| `addConstraintJobListWorkingTimeIntersect` | <span data-ttu-id="81977-213">Tilføjer en begrænsning, hvor de kapacitetspladser, der er reserveret til jobbene, skal være på skæringsarbejdstider for de to ressourcer, der bruges af jobbene.</span><span class="sxs-lookup"><span data-stu-id="81977-213">Adds a constraint that the capacity slots reserved for the jobs must be on the intersecting working times for the two resources used by the jobs.</span></span> |
| `addConstraintJobOverlap` | <span data-ttu-id="81977-214">Tilføj en begrænsning, der definerer, hvordan jobsekvens beregnes, når et bestemt antal af en vare kan flyttes mellem to ressourcer, mens den første ressource stadig ikke er færdigbehandlet, så den anden ressource kan starte behandlingen.</span><span class="sxs-lookup"><span data-stu-id="81977-214">Add a constraint that defines how jobs are sequenced when a given quantity of an item can be moved between two resources while the first resource is still not finished processing, so that the second resource can start processing.</span></span> |
| `addConstraintNotOnSameResource` | <span data-ttu-id="81977-215">Tilføjer en begrænsning for, at to job ikke må planlægges på samme ressource.</span><span class="sxs-lookup"><span data-stu-id="81977-215">Adds a constraint that two jobs should not be scheduled on the same resource.</span></span> |
| `addConstraintOnSameResource` | <span data-ttu-id="81977-216">Tilføjer en begrænsning for, at to job skal bruge samme ressource.</span><span class="sxs-lookup"><span data-stu-id="81977-216">Adds a constraint that two jobs must be using the same resource.</span></span> |
| `addJobSameReservations` | <span data-ttu-id="81977-217">Tilføjer en begrænsning, hvor et job skal have kapacitetsreservationer i samme tidsrum som det primære job.</span><span class="sxs-lookup"><span data-stu-id="81977-217">Adds a constraint that a job must end up having capacity reservations for the same time slots as the primary job.</span></span> |
| `setPrimaryParallelJob` | <span data-ttu-id="81977-218">Tilføjer oplysninger om det primære job i et sæt parallelle job.</span><span class="sxs-lookup"><span data-stu-id="81977-218">Adds information about what job is the primary job in a set of parallel jobs.</span></span> |

### <a name="solver"></a><span data-ttu-id="81977-219">Problemløser</span><span class="sxs-lookup"><span data-stu-id="81977-219">Solver</span></span>

<span data-ttu-id="81977-220">Selve programmet er egentligt en specialiseret begrænsningsløser med brugerdefineret heuristisk tilføjelse.</span><span class="sxs-lookup"><span data-stu-id="81977-220">The engine itself is essentially a specialized constraint solver with custom heuristics added.</span></span> <span data-ttu-id="81977-221">Problemløseren er baseret på to hovedelementer: variabler og begrænsninger.</span><span class="sxs-lookup"><span data-stu-id="81977-221">The solver is based on two main elements: variables and constraints.</span></span>

#### <a name="variable"></a><span data-ttu-id="81977-222">Variabelt</span><span class="sxs-lookup"><span data-stu-id="81977-222">Variable</span></span>

<span data-ttu-id="81977-223">En variabel repræsenterer et domæne af mulige værdier.</span><span class="sxs-lookup"><span data-stu-id="81977-223">A variable represents a domain of possible values.</span></span> <span data-ttu-id="81977-224">Planlægningsprogrammet har to typer variabler:</span><span class="sxs-lookup"><span data-stu-id="81977-224">Scheduling engine has two types of variables:</span></span>

- <span data-ttu-id="81977-225">**DateTime-variabel** - Har et domæne for alle datoer og klokkeslæt, og domænet kan begrænses ved at flytte den nedre og øvre grænse for tidspunktet for variablen tættere på hinanden.</span><span class="sxs-lookup"><span data-stu-id="81977-225">**DateTime variable** - Has a domain of all dates and times, and the domain can be restricted by moving the lower and upper bound for the time of the variable closer to each other.</span></span>
- <span data-ttu-id="81977-226">**Ressourcevariabel** – Har et domæne med relevante ressourcer, og domænet kan begrænses ved at fjerne ressourcer fra listen.</span><span class="sxs-lookup"><span data-stu-id="81977-226">**Resource variable** - Has a domain of applicable resources, and the domain can be restricted by eliminating resources from the list.</span></span>

#### <a name="constraint"></a><span data-ttu-id="81977-227">Begrænsning</span><span class="sxs-lookup"><span data-stu-id="81977-227">Constraint</span></span>

<span data-ttu-id="81977-228">En begrænsning fungerer på variabler ved at begrænse deres domæner, men den afhænger også af variabler, så den aktiveres, når variabler ændres.</span><span class="sxs-lookup"><span data-stu-id="81977-228">A constraint acts on variables by restricting their domains, but it also depends on variables so it gets activated when variables change.</span></span> <span data-ttu-id="81977-229">Processen med "begrænsningsudbredelse" er, når en begrænsning udfører sin hovedfunktion og rapporterer tilbage til hovedlogikken, hvis den lykkes.</span><span class="sxs-lookup"><span data-stu-id="81977-229">The process of "constraint propagation" is when a constraint performs its main function and reports back to the main logic if successful.</span></span>

<span data-ttu-id="81977-230">En variabel betragtes som bundet, når den ikke kan begrænses yderligere, hvilket for en DateTime-variabel betyder, at den øvre og nedre grænse er den samme og for ressourcevariablen, at den kun har en enkelt anvendelig ressource.</span><span class="sxs-lookup"><span data-stu-id="81977-230">A variable is considered bound when it can't be restricted further, which for DateTime variable means that upper and lower bound is the same, and for the Resource variable that it has only a single applicable resource.</span></span> <span data-ttu-id="81977-231">Når alle variabler er bundet, findes der en løsning.</span><span class="sxs-lookup"><span data-stu-id="81977-231">When all variables are bound, a solution is found.</span></span>

### <a name="constraint-levels"></a><span data-ttu-id="81977-232">Begrænsningsniveauer</span><span class="sxs-lookup"><span data-stu-id="81977-232">Constraint levels</span></span>

<span data-ttu-id="81977-233">Når der udføres planlægning som en del af materialebehovsplanlægning (MRP), planlægges ordrerne bagud fra behovsdatoen.</span><span class="sxs-lookup"><span data-stu-id="81977-233">When scheduling is executed as part of the material requirements planning (MRP) coverage phase, the orders will be scheduled backward from requirement date.</span></span> <span data-ttu-id="81977-234">Men hvis det ikke er muligt at finde en tidsplan, der starter i dag eller senere og slutter før behovsdatoen, ændres planlægningsretningen til fremad fra i dag.</span><span class="sxs-lookup"><span data-stu-id="81977-234">However, if it is not possible to find a schedule that starts today or later and ends before the requirement date, then the scheduling direction will change to forward from today.</span></span>

<span data-ttu-id="81977-235">Denne hovedforretningsregel håndteres ved at organisere begrænsningerne i niveauer.</span><span class="sxs-lookup"><span data-stu-id="81977-235">This main business rule is handled by organizing the constraints in levels.</span></span> <span data-ttu-id="81977-236">Hvis der ikke findes en løsning, når du bruger begrænsningerne på det højeste niveau, droppes alle begrænsningerne på det pågældende niveau, og det lavere niveau afprøves.</span><span class="sxs-lookup"><span data-stu-id="81977-236">If no solution is found when using the constraints on the highest level, then the constraints on that level are all dropped, and the lower level is tried.</span></span> <span data-ttu-id="81977-237">I praksis betyder det, at i forbindelse med planlægning bagud vil modellen indeholde et niveau 1 med jobmål for det seneste givne starttidspunkt og en maksimal sluttid som begrænsning (behovsdatoen), og et niveau 0 med jobmål for det tidligste sluttidspunkt og en given minimumstarttid af i dag.</span><span class="sxs-lookup"><span data-stu-id="81977-237">In praxis, this means that for backward scheduling the model will contain a level 1 with job goals of latest start time given a maximum end time constraint (the requirement date), and a level 0 with job goals of earliest end time and given a minimum start time constraint of today.</span></span>

### <a name="algorithm"></a><span data-ttu-id="81977-238">Algoritme</span><span class="sxs-lookup"><span data-stu-id="81977-238">Algorithm</span></span>

<span data-ttu-id="81977-239">Hovedtrin i programalgoritmen er:</span><span class="sxs-lookup"><span data-stu-id="81977-239">The main steps of the engine algorithm are:</span></span>

1. <span data-ttu-id="81977-240">Find sekvenser (jobkæder), der kan løses særskilt.</span><span class="sxs-lookup"><span data-stu-id="81977-240">Find sequences (job chains) which can be solved separately.</span></span>
1. <span data-ttu-id="81977-241">Prøv at finde en indledende løsning på sekvensen for det højeste begrænsningsniveau.</span><span class="sxs-lookup"><span data-stu-id="81977-241">Try to find an initial solution for the sequence for the highest constraint level.</span></span>
    1. <span data-ttu-id="81977-242">Sortér job i rækkefølge baseret på jobmål og -prioriteter, så der findes et startjob.</span><span class="sxs-lookup"><span data-stu-id="81977-242">Sort the jobs in the sequence based on job goal and priorities, such that a start job can be found.</span></span>
    1. <span data-ttu-id="81977-243">Gentag jobbene i følgende rækkefølge:</span><span class="sxs-lookup"><span data-stu-id="81977-243">Loop the jobs in the following sequence:</span></span>
        1. <span data-ttu-id="81977-244">Find alle de begrænsninger, der skal udbredes, og kør udbredelse.</span><span class="sxs-lookup"><span data-stu-id="81977-244">Find all constraints that need to be propagated and run propagation.</span></span>
        1. <span data-ttu-id="81977-245">Hvis alle variabler for jobbet er bundet, er der fundet en løsning til det pågældende job.</span><span class="sxs-lookup"><span data-stu-id="81977-245">If all variables for the job have been bound, then a solution for that job has been found.</span></span>
        1. <span data-ttu-id="81977-246">Hvis en af variablerne ikke kan bindes, uden at begrænsningerne overtrædes, skal du annullere variabelbindingen, prøve en anden værdi i domænet (for ressourcevariablen) og køre begrænsningsudbredelsen igen.</span><span class="sxs-lookup"><span data-stu-id="81977-246">If one of the variables could not be bound without violating the constraints, then roll back the variable binding, try a different value in the domain (for resource variable), and rerun the constraint propagation.</span></span>
1. <span data-ttu-id="81977-247">Hvis der ikke blev fundet en løsning, fjernes alle begrænsninger på det aktuelle begrænsningsniveau, mens begrænsningsniveauet sænkes (hvis der er nogle lavere tilgængelige niveauer), og søgning efter løsninger blev forsøgt igen med det nye sæt begrænsninger.</span><span class="sxs-lookup"><span data-stu-id="81977-247">If no solution was found, then all constraints on the current constraint level is removed, the constraint level lowered (if any lower levels are available) and solution search retried with the new set of constraint.</span></span>
1. <span data-ttu-id="81977-248">Hvis der findes en passende løsning, startes optimeringsfasen, som vil forsøge at finde en bedre løsning, indtil timeout for optimering opstår, eller alle ressourcekombinationer er opbrugt.</span><span class="sxs-lookup"><span data-stu-id="81977-248">If a feasible solution was found, then the optimization phase is started, which will try to find a better solution until the optimization timeout is reached or all resource combinations have been exhausted.</span></span>

<span data-ttu-id="81977-249">Begrænsningsløseren er ikke klar over de specifikke oplysninger om planlægningsalgoritmen.</span><span class="sxs-lookup"><span data-stu-id="81977-249">The constraint solver is not aware of the specifics of the scheduling algorithm.</span></span> <span data-ttu-id="81977-250">Den har en definition og en kombination af de forskellige begrænsninger, som forekommer.</span><span class="sxs-lookup"><span data-stu-id="81977-250">It is in the definition and combination of the various constraints that the "magic" happens.</span></span>

### <a name="determining-working-times"></a><span data-ttu-id="81977-251">Fastlægge arbejdstider</span><span class="sxs-lookup"><span data-stu-id="81977-251">Determining working times</span></span>

<span data-ttu-id="81977-252">En stor del af begrænsningerne (interne) i programmet styrer en ressources arbejdstid og kapacitet.</span><span class="sxs-lookup"><span data-stu-id="81977-252">A large part of the (internal) constraints in the engine controls the working time and capacity of a resource.</span></span> <span data-ttu-id="81977-253">Opgaven er grundlæggende at føre arbejdstidsrummet for en ressource fra et givent sted i en given retning og finde et langt nok interval, hvor den krævede jobkapacitet (tid) kan være.</span><span class="sxs-lookup"><span data-stu-id="81977-253">Essentially, the task is to traverse the working time slots for a resource from a given point in a given direction, and find a long enough interval in which the jobs required capacity (time) can fit.</span></span>

<span data-ttu-id="81977-254">Hvis du vil gøre det, skal programmet kende en ressources arbejdstider.</span><span class="sxs-lookup"><span data-stu-id="81977-254">To do this, the engine needs to know the working times of a resource.</span></span> <span data-ttu-id="81977-255">Modsat hovedmodeldata bliver arbejdstiderne *gradvist indlæst*, hvilket betyder, at de indlæses i programmet efter behov.</span><span class="sxs-lookup"><span data-stu-id="81977-255">Opposite to the main model data, the working times are *lazy loaded*, meaning that they are loaded into the engine as needed.</span></span> <span data-ttu-id="81977-256">Årsagen til denne metode er, at der ofte er arbejdstider i Supply Chain Management for en kalender i en meget lang periode, og der findes typisk mange kalendere, så dataene bliver meget store at indlæse på forhånd.</span><span class="sxs-lookup"><span data-stu-id="81977-256">The reason for this approach is that there are often working times in Supply Chain Management for a calendar for a very long period and typically many calendars exist so the data would be quite large to pre-load.</span></span>

<span data-ttu-id="81977-257">Der anmodes om kalenderoplysninger af programmet i segmenter ved at kalde X++-klassemetoden `WrkCtrSchedulingInteropDataProvider.getWorkingTimes`.</span><span class="sxs-lookup"><span data-stu-id="81977-257">Calendar information is requested by the engine in chunks, by invoking the X++ class method `WrkCtrSchedulingInteropDataProvider.getWorkingTimes`.</span></span> <span data-ttu-id="81977-258">Anmodningen gælder for et bestemt kalender-id i et bestemt tidsinterval.</span><span class="sxs-lookup"><span data-stu-id="81977-258">The request is for a specific calendar ID in a specific time interval.</span></span> <span data-ttu-id="81977-259">Afhængigt af servercachens tilstand i Supply Chain Management kan hver enkelt af disse anmodninger ende med flere databasekald, hvilket tager lang tid (i forhold til den rene beregningstid).</span><span class="sxs-lookup"><span data-stu-id="81977-259">Depending on the state of the server cache in Supply Chain Management, each of these requests could end up in several database calls, which takes a long time (relative to the pure computational time).</span></span> <span data-ttu-id="81977-260">Hvis kalenderen desuden indeholder meget komplekse arbejdstidsdefinitioner med mange arbejdstidsintervaller pr. dag, giver det en længere indlæsningstid.</span><span class="sxs-lookup"><span data-stu-id="81977-260">Also, if the calendar contains very elaborate working time definitions with many working time intervals per day, this adds to the time the loading takes.</span></span>

<span data-ttu-id="81977-261">Når der indlæses arbejdstidsdata i planlægningsprogrammet, bevares de i dens interne cache for den specifikke kalender, hvilket betyder, at hvis andre job eller ressourcer bruger samme kalender, kan de næste opslag hurtigt udføres fra hukommelsen.</span><span class="sxs-lookup"><span data-stu-id="81977-261">When the working time data is loaded in the scheduling engine, this is retained in its internal cache for the specific calendar, meaning that if any other jobs or resources are using the same calendar then the next lookups can be performed quickly from memory.</span></span> <span data-ttu-id="81977-262">En almindelig årsag til dårlig ydeevne er, hvis der bruges et separat kalender-id til hver ressource, da der så kræves data for hver kalender, selvom indholdet i kalenderne kan være ens.</span><span class="sxs-lookup"><span data-stu-id="81977-262">One common cause of bad performance is if a separate calendar ID is used for each resource, because data will then need to be requested for each calendar, even though the content of the calendars might be the same.</span></span>

### <a name="finite-capacity"></a><span data-ttu-id="81977-263">Kapacitetsbegrænsning</span><span class="sxs-lookup"><span data-stu-id="81977-263">Finite capacity</span></span>

<span data-ttu-id="81977-264">Når der bruges kapacitetsbegrænsning, vil arbejdstiden fra kalenderen blive opdelt og reduceret ud fra de eksisterende kapacitetsreservationer.</span><span class="sxs-lookup"><span data-stu-id="81977-264">When using finite capacity, the working time slots from the calendar are split and reduced based on the existing capacity reservations.</span></span> <span data-ttu-id="81977-265">Disse reservationer hentes også via samme `WrkCtrSchedulingInteropDataProvider`-klasse som kalenderne, men i stedet bruges metoden `getCapacityReservations`.</span><span class="sxs-lookup"><span data-stu-id="81977-265">These reservations are also fetched through the same `WrkCtrSchedulingInteropDataProvider` class as the calendars, but instead use the method `getCapacityReservations`.</span></span> <span data-ttu-id="81977-266">Når der planlægges under varedisponering, betragtes reservationerne for den specifikke behovsplan, og hvis den er aktiveret på siden **Varedisponeringsparametre**, medtages reservationer fra autoriserede produktionsordrer også.</span><span class="sxs-lookup"><span data-stu-id="81977-266">When scheduling during master planning, the reservations for the specific master plan are considered and if enabled on the **Master planning parameters** page, the reservations from firmed production orders are also included.</span></span> <span data-ttu-id="81977-267">Når en produktionsordre planlægges, kan du også vælge at medtage reservationer fra eksisterende ordreforslag, selvom dette ikke er så almindeligt som den anden metode.</span><span class="sxs-lookup"><span data-stu-id="81977-267">Similarly, when scheduling a production order, it is also an option to include reservations from existing planned orders, although this is not as common as the other way around.</span></span>

<span data-ttu-id="81977-268">Hvis du bruger kapacitetsbegrænsning, kan planlægningen tage længere tid af flere årsager:</span><span class="sxs-lookup"><span data-stu-id="81977-268">Using finite capacity will cause scheduling to take longer due to several reasons:</span></span>

- <span data-ttu-id="81977-269">Hentning af kapacitetsoplysninger fra databasen er en langsom operation, og cachelagringen af kapacitetsoplysninger på serversiden er typisk ikke så god som for arbejdstider, fordi de ikke deles mellem ressourcer som f.eks. kalendere.</span><span class="sxs-lookup"><span data-stu-id="81977-269">Fetching the capacity information from database is a slow operation and the server-side caching of capacity information is typically not as good as for working times because they are not shared among resources like calendars typically are.</span></span>
- <span data-ttu-id="81977-270">Antallet af arbejdstider, der skal håndteres, øges på grund af opdelingerne, og tidsintervaller for en længere tidsperiode skal normalt undersøges, før der kan findes en løsning.</span><span class="sxs-lookup"><span data-stu-id="81977-270">The number of working time slots to traverse increases due to the splits, and slots for a longer time period must typically be investigated before a solution can be found.</span></span>
- <span data-ttu-id="81977-271">Når planlægningen er fuldført, skal der udføres en kontrol af, om der er uoverensstemmende reservationer (se afsnittet "Kørsel af flere planlægningsprogrammer parallelt" for at få flere oplysninger).</span><span class="sxs-lookup"><span data-stu-id="81977-271">After the scheduling is complete, a check for conflicting reservations must be performed (see the "Running scheduling engines in parallel" section for details).</span></span>

### <a name="examining-the-resource-combinations"></a><span data-ttu-id="81977-272">Undersøgelse af ressourcekombinationerne</span><span class="sxs-lookup"><span data-stu-id="81977-272">Examining the resource combinations</span></span>

<span data-ttu-id="81977-273">Hvis jobrækkefølgen kun indeholder standardlinks `FinishStart`, hvilket betyder, at den udgør en simpel kæde uden forgreninger, kan der opnås et optimalt resultat (set fra den enkelte ordres side, ikke på tværs af ordrer) ved at finde den bedste løsning til det første job og derefter finde den bedste løsning til det næste job.</span><span class="sxs-lookup"><span data-stu-id="81977-273">If the job sequence only contains the standard `FinishStart` links, meaning it forms a simple chain without any branches, an optimal result (seen from the single order, not across orders) can be achieved by finding the best solution for the first job and then moving on to find the best solution for the next job.</span></span> <span data-ttu-id="81977-274">Den bedste løsning til et job betyder, at du finder den ressource, der kan hente fra- og til-datoen for det job, der er tættest på jobmålet (i forlæns planlægning betyder det at få slutdatoen i jobbet så tidligt som muligt), samtidig med at begrænsningerne overholdes.</span><span class="sxs-lookup"><span data-stu-id="81977-274">The best solution for a job means finding the resource that can get the from and to date of the job closest to the job goal (in forward scheduling this means getting the end date of the job as early as possible) while still respecting the constraints.</span></span>

<span data-ttu-id="81977-275">Når der er parallelle job, kan søgning efter en løsning omfatte forskellige kombinationer af ressourcer.</span><span class="sxs-lookup"><span data-stu-id="81977-275">When there are parallel jobs, finding a solution may involve examining different combinations of resources.</span></span> <span data-ttu-id="81977-276">Antallet af mulige ressourcekombinationer er produktet af antallet af relevante ressourcer for de forbundne parallelle job.</span><span class="sxs-lookup"><span data-stu-id="81977-276">The number of possible resource combinations is the product of the number of applicable resources for the connected parallel jobs.</span></span> <span data-ttu-id="81977-277">Specielt når du planlægger en ordre baglæns fra en behovsdato, kan det tage ret lang tid for logikken at indse, at der ikke er nogen løsning på det problem, der vil kunne opfylde de parallelle job før dags dato, da det vil være nødvendigt at kontrollere alle kombinationerne, fordi der kan være ressourcer med en højere effektivitet eller en anden kalender, der kan give et resultat.</span><span class="sxs-lookup"><span data-stu-id="81977-277">Especially when scheduling an order backwards from a requirement date, it can take quite a while for the logic to realize that there is no solution to the problem that will make the parallel jobs fit before today's date, as it will need to check all the combinations because there could be some resources that had a higher efficiency or a different calendar that might give a result.</span></span> <span data-ttu-id="81977-278">Det betyder, at hvis der ikke er angivet timeoutgrænse, køres den i lang tid, før retningen ændres til fremad.</span><span class="sxs-lookup"><span data-stu-id="81977-278">This means that if no timeout limit has been set it will run for a long time before changing the direction to forward.</span></span>

<span data-ttu-id="81977-279">Denne kombinationslogik betyder også, at hvis du tilføjer mere relevante ressourcer, kan programmet blive kørt langsommere.</span><span class="sxs-lookup"><span data-stu-id="81977-279">This combinatorial logic also means that adding more applicable resources may make the engine run slower.</span></span> <span data-ttu-id="81977-280">Hvis der opstår ydeevneproblemer, når der er parallelle operationer og planlægning med ubegrænset kapacitet, kan den rettes delvist ved at få rutedesignere til at træffe en beslutning om, hvilken ressource der skal bruges, og derefter tildele ressourcen direkte til operationen (da programmet i de fleste tilfælde altid vil ende med at vælge den samme ressource, så slutresultatet vil være det samme).</span><span class="sxs-lookup"><span data-stu-id="81977-280">If performance problems occur when having parallel operations and scheduling with infinite capacity, it can partly be fixed by having the route designer take a decision on which resource should be used and then assign the resource directly on the operation (because the engine in most cases will always end up picking the same resource, so the end result will be the same).</span></span>

### <a name="hard-links"></a><span data-ttu-id="81977-281">Hårde links</span><span class="sxs-lookup"><span data-stu-id="81977-281">Hard links</span></span>

<span data-ttu-id="81977-282">Hvis du angiver linktypen mellem to job til hård, sikrer du, at der ikke er tidskløfter mellem afslutningen på ét job og begyndelsen af det næste.</span><span class="sxs-lookup"><span data-stu-id="81977-282">Setting the link type between two jobs to hard, ensures that there is no time gap between the finish of one job and the start of the next one.</span></span> <span data-ttu-id="81977-283">Dette kan være meget nyttigt i scenarier, hvor metal f.eks. opvarmes i ét job og derefter behandles i det næste job, hvor det ikke er ønskeligt at få metal afkølet i mellemtiden.</span><span class="sxs-lookup"><span data-stu-id="81977-283">This can be very useful in scenarios like when metal is heated in one job and then processed in the next job, where it is not desirable to have the metal cool down in between.</span></span>

<span data-ttu-id="81977-284">Hvis ruten udgør en simpel kæde uden forgreninger, kan der opnås et resultat med bløde standardlinks og forlæns planlægning ved at finde en løsning til det første job, der opfylder sine egne begrænsninger, og derefter gå videre igennem kæden og overføre sluttidspunktet fra det forrige job til det næste job.</span><span class="sxs-lookup"><span data-stu-id="81977-284">With standard soft links and forward scheduling, if the route forms a simple chain without any branches, a result can be achieved by finding a solution for the first job that satisfies its own constraints and then moving on through the chain propagating the end time from the previous job to the next job.</span></span> <span data-ttu-id="81977-285">Hvis det aktuelle job ikke kan finde en kapacitet, vil starttidspunktet for det blive flyttet yderligere uden risiko for, at de tidligere job skaber pauser mellem jobbene.</span><span class="sxs-lookup"><span data-stu-id="81977-285">If the current job can't find any capacity, the start time for it will be moved out further, without any consequence for the previous jobs potentially creating gaps between the jobs.</span></span> <span data-ttu-id="81977-286">Men med hårde links (især i forbindelse med kapacitetsbegrænsning) for det samme scenarie er det faktum, at ét job senere i kæden ikke kan finde kapacitet, hvilket vil sige, at alle tidligere planlagte job skal "trækkes" med ét efter ét og derved omplanlægges et antal gange.</span><span class="sxs-lookup"><span data-stu-id="81977-286">However with hard links (especially in connection with finite capacity) for the same scenario, the fact that one job later in the chain cannot find capacity, will mean that all previous scheduled jobs will have to be "dragged" along one by one and thereby rescheduled a number of times.</span></span> <span data-ttu-id="81977-287">Især i scenarier med høj belastning af flere ressourcer kan hårde links forårsage en kædereaktion, hvor jobbene påvirker hinanden, og der skal udføres et antal gentagelser, før resultatet bliver stabiliseret ind i en gennemførlig plan.</span><span class="sxs-lookup"><span data-stu-id="81977-287">Especially in scenarios with high load for multiple resources, the hard links can cause a chain reaction where the jobs will affect each other and a number of iterations will have to be performed before the result stabilizes into a feasible schedule.</span></span>

## <a name="running-scheduling-engines-in-parallel"></a><span data-ttu-id="81977-288">Kørsel af planlægningsprogrammer parallelt</span><span class="sxs-lookup"><span data-stu-id="81977-288">Running scheduling engines in parallel</span></span>

<span data-ttu-id="81977-289">Når der udføres planlægning som del af en varedisponeringskørsel, hvor der bruges hjælpefunktioner, kan hvert af hjælpetrådene for varedisponering også vælge produktionsordres planlægningsopgaver.</span><span class="sxs-lookup"><span data-stu-id="81977-289">When performing scheduling as part of a master planning run where helpers are used, each of the master planning helper threads can also pick up production order scheduling tasks.</span></span> <span data-ttu-id="81977-290">Det betyder, at der kan køre flere planlægningsprogrammer samtidigt.</span><span class="sxs-lookup"><span data-stu-id="81977-290">This means that multiple scheduling engines can be running at the same time.</span></span> <span data-ttu-id="81977-291">Mens flertrådede funktioner i almindelighed er en stor fordel for ydeevnen, er der også nogle funktionelle ulemper, når det kommer til planlægning.</span><span class="sxs-lookup"><span data-stu-id="81977-291">While multithreading in general is a highly significant performance benefit, there are also some functional downsides when it comes to scheduling.</span></span>

<span data-ttu-id="81977-292">I MRP planlægges alle produktionsordrer for et bestemt styklisteniveau i behovsdatodatosekvensen, hvilket betyder, at de ordrer, der har den tidligste behovsdato, skal planlægges først og dermed have størst chance for at få den tilgængelige ressourcekapacitet.</span><span class="sxs-lookup"><span data-stu-id="81977-292">In MRP, all production orders for a given bill of materials (BOM) level are scheduled in requirement date sequence, meaning that those orders with the earliest requirement date should be scheduled first and thereby have the highest chance of getting the available resource capacity.</span></span> <span data-ttu-id="81977-293">Men når flere programmer plukker fra listen over ikke-planlagte ordrer er sekvensen ikke længere sikret, da den kan være fuldført hurtigere end en anden.</span><span class="sxs-lookup"><span data-stu-id="81977-293">However, with multiple engines picking from the list of unscheduled orders the sequence is no longer ensured, as one might complete faster than the other.</span></span>

<span data-ttu-id="81977-294">Når der planlægges med kapacitetsbegrænsning, og når flere programforekomster forsøger at planlægge ordrer, der potentielt bruger de samme ressourcer i samme tidsinterval, kan der forekomme et kapløb.</span><span class="sxs-lookup"><span data-stu-id="81977-294">Also, when scheduling using finite capacity and when multiple engine instances are trying to schedule orders that are potentially using the same resources at the same time interval, a race condition can occur.</span></span> <span data-ttu-id="81977-295">Antallet af sådanne kapløbsbetingelser registreres i feltet **Planlægningskonflikter** på siden historik for behovsplaner.</span><span class="sxs-lookup"><span data-stu-id="81977-295">The number of such race conditions is recorded in the **Scheduling conflicts** field on the master plans history page.</span></span> <span data-ttu-id="81977-296">Konfliktløsningslogikken er følgende:</span><span class="sxs-lookup"><span data-stu-id="81977-296">The conflict resolution logic is as follows:</span></span>

- <span data-ttu-id="81977-297">Planlæg en ordre (låsefri), og få kapacitetsreservationer.</span><span class="sxs-lookup"><span data-stu-id="81977-297">Schedule an order (lock-free) and get capacity reservations.</span></span>
- <span data-ttu-id="81977-298">Tag låsen.</span><span class="sxs-lookup"><span data-stu-id="81977-298">Take the lock.</span></span>
- <span data-ttu-id="81977-299">Kontrollér, om der findes nyere kapacitetsreservationer for de planlagte ressourcer i tidsintervallet.</span><span class="sxs-lookup"><span data-stu-id="81977-299">Check if newer capacity reservations exist for the scheduled resources in the timespan.</span></span>
  - <span data-ttu-id="81977-300">Hvis ikke, skal du skrive kapaciteten og frigive låsen.</span><span class="sxs-lookup"><span data-stu-id="81977-300">If no, write the capacity and release the lock.</span></span>
  - <span data-ttu-id="81977-301">Hvis ja, skal du frigive låsen og genplanlægge ordren fra begyndelsen.</span><span class="sxs-lookup"><span data-stu-id="81977-301">If yes, release the lock and reschedule the order from the beginning.</span></span>

<span data-ttu-id="81977-302">Når der planlægges med flere programforekomster, vil resultatet derfor ikke være fuldstændigt fastlagt, da det afhænger af den nøjagtige timing af hver tråd.</span><span class="sxs-lookup"><span data-stu-id="81977-302">So, when scheduling with multiple engine instances, the result is not fully deterministic because it will depend on the exact timing of each of the threads.</span></span>

## <a name="operation-scheduling-performance"></a><span data-ttu-id="81977-303">Ydeevne af grovplanlægning</span><span class="sxs-lookup"><span data-stu-id="81977-303">Operation scheduling performance</span></span>

<span data-ttu-id="81977-304">Selvom operationsplanlægning også kaldes en grov planlægning af kapaciteten set fra et programsynspunkt, kan det være et sværere problem at løse, hvis kapacitetsbegrænsning bruges, da der er behov for flere data til at fastlægge gennemførligheden.</span><span class="sxs-lookup"><span data-stu-id="81977-304">Even though operation scheduling is also known as rough-cut capacity planning, seen from an engine standpoint, it can be a harder problem to solve if finite capacity is used, as more data is needed to determine feasibility.</span></span>

<span data-ttu-id="81977-305">Kapaciteten for en ressourcegruppe afhænger af, hvilke og hvor mange ressourcer der er medlemmer af ressourcegruppen.</span><span class="sxs-lookup"><span data-stu-id="81977-305">The capacity of a resource group depends on which and how many resources are members of the resource group.</span></span> <span data-ttu-id="81977-306">En ressourcegruppe har i sig selv ingen kapacitet. Når ressourcer er medlem af gruppen, har de kapacitet.</span><span class="sxs-lookup"><span data-stu-id="81977-306">A resource group in itself does not have any capacity&mdash;only when resources are a member of the group will it have capacity.</span></span> <span data-ttu-id="81977-307">Da medlemskabet af ressourcegruppen kan variere over tid, skal kapacitet evalueres pr. dag.</span><span class="sxs-lookup"><span data-stu-id="81977-307">Because the resource group membership can vary over time, capacity must be evaluated per day.</span></span>

<span data-ttu-id="81977-308">Ved grovplanlægning bruges ressourcegruppens kalender til at bestemme start- og sluttidspunkter for hver operation.</span><span class="sxs-lookup"><span data-stu-id="81977-308">In operations scheduling, the resource group's calendar is used to determine the start and end times for each operation.</span></span> <span data-ttu-id="81977-309">Det betyder, at ressourcegruppens kalender angiver en grænse for, hvor lang tid der kan planlægges operationer for én operation på én dag i én ressourcegruppe.</span><span class="sxs-lookup"><span data-stu-id="81977-309">This means that the resource group's calendar places a limit on how much time can be operations scheduled for one operation on one day in one resource group.</span></span> <span data-ttu-id="81977-310">Modsat kalenderen for de specifikke ressourcer ignoreres kalenderens effektivitetsdata for ressourcegruppen, da den blot angiver åbningstider og ikke faktisk kapacitet.</span><span class="sxs-lookup"><span data-stu-id="81977-310">Opposite the calendar for the specific resources, the efficiency data of the calendar is ignored for the resource group as it simply denotes opening hours and not actual capacity.</span></span>

<span data-ttu-id="81977-311">Hvis arbejdstiden for en ressourcegruppe på en bestemt dato f.eks. er fra 8:00 til 16:00, kan en operation ikke lægge mere belastning på ressourcegruppen, end der kan være i løbet af 8 timer, uanset hvor meget kapacitet ressourcegruppen har tilgængelig i alt på den pågældende dag.</span><span class="sxs-lookup"><span data-stu-id="81977-311">For example, if the working time for a resource group on one specific date is from 8:00 to 16:00, one operation can't put more load on the resource group than what can be fit into 8 hours, no matter how much capacity that the resource group has available in total on that day.</span></span> <span data-ttu-id="81977-312">Den tilgængelige kapacitet kan dog begrænse belastningen yderligere.</span><span class="sxs-lookup"><span data-stu-id="81977-312">The available capacity can however limit the load further.</span></span>

<span data-ttu-id="81977-313">Belastningen fra finplanlægning for alle de ressourcer, der er medtaget i ressourcegruppen på en given dag, tages i betragtning, når den tilgængelige kapacitet for ressourcegruppen på samme dag beregnes.</span><span class="sxs-lookup"><span data-stu-id="81977-313">The load from job scheduling on all the resources included in the resource group on a given day is considered when the available capacity for the resource group on the same day is calculated.</span></span> <span data-ttu-id="81977-314">For hver dato er beregningen:</span><span class="sxs-lookup"><span data-stu-id="81977-314">For each date, the calculation is:</span></span>

<span data-ttu-id="81977-315">*Tilgængelig ressourcegruppekapacitet = kapaciteten for ressourcer i gruppen baseret på deres kalender &ndash; finplanlagt belastning af ressourcerne i gruppen &ndash; grovplanlagt belastning af ressourcerne i gruppen &ndash; grovplanlagt belastning af ressourcegruppen*</span><span class="sxs-lookup"><span data-stu-id="81977-315">*Available resource group capacity = Capacity for resources in the group based on their calendar &ndash; Job scheduled load on the resources in the group &ndash; Operations scheduled load on the resources in the group &ndash; Operations scheduled load on the resource group*</span></span>

<span data-ttu-id="81977-316">Under fanen **Ressourcekrav** i ruteoperationen kan ressourcekrav angives ved hjælp af enten en bestemt ressource (i dette tilfælde planlægges operationen ved hjælp af den pågældende ressource) for en ressourcegruppe, for en ressourcetype eller for en eller flere egenskaber, færdighed, kursus eller certifikat.</span><span class="sxs-lookup"><span data-stu-id="81977-316">On the **Resource requirements** tab on the route operation, the resource requirements can be specified using either a specific resource (in which case the operation will be scheduled using that resource), for a resource group, for a resource type, or for one or more capabilities, skill, course, or certificate.</span></span> <span data-ttu-id="81977-317">Når du bruger alle disse indstillinger, giver det en stor fleksibilitet for rutedesignet, men det komplicerer også planlægningen af programmet, som kapaciteten skal redegøres for pr. "egenskab" (det abstrakte navn, der bruges i programmet, for egenskab, kompetencer osv.).</span><span class="sxs-lookup"><span data-stu-id="81977-317">While using all of these options gives a great flexibility on the route design, it also complicates the scheduling for the engine as the capacity must be accounted for per "property" (the abstract name used in the engine for capability, skills, and so on).</span></span>

<span data-ttu-id="81977-318">Ressourcegruppens kapacitet for en egenskab er summen af kapaciteten for alle ressourcer i den ressourcegruppe, der har den pågældende egenskab.</span><span class="sxs-lookup"><span data-stu-id="81977-318">The resource group's capacity for a capability is the sum of the capacity for all resources in the resource group that has the capability in question.</span></span> <span data-ttu-id="81977-319">Hvis en ressource i gruppen har en egenskab, medregnes den, uanset hvilket kapacitetsniveau der kræves.</span><span class="sxs-lookup"><span data-stu-id="81977-319">If a resource in the group has a capability, it will be considered no matter what level of the capacity is required.</span></span>

<span data-ttu-id="81977-320">I forbindelse med grovplanlægning reduceres den disponible kapacitet for en bestemt egenskab i en ressourcegruppe, når den indlæses med en operation, der kræver den pågældende egenskab.</span><span class="sxs-lookup"><span data-stu-id="81977-320">In operations scheduling, the available capacity for a certain capability for a resource group will be reduced when it is loaded with an operation that requires the capability in question.</span></span> <span data-ttu-id="81977-321">Hvis operationen kræver mere end én egenskab, vil kapaciteten blive reduceret for alle de krævede egenskaber.</span><span class="sxs-lookup"><span data-stu-id="81977-321">If the operation requires more than one capability, the capacity will be reduced for all required capabilities.</span></span>

<span data-ttu-id="81977-322">For hver dato er den påkrævede beregning:</span><span class="sxs-lookup"><span data-stu-id="81977-322">For each date, the required calculation is:</span></span>

<span data-ttu-id="81977-323">*Ledig kapacitet for en egenskab = kapacitet for egenskaben &ndash; finplanlagt belastning af ressourcerne med den specifikke egenskab, der er medtaget i ressourcegruppen &ndash; grovplanlagt belastning af ressourcer med den specifikke egenskab, der er medtaget i ressourcegruppen &ndash; grovplanlagt belastning af selve ressourcegruppen, der kræver den specifikke egenskab*</span><span class="sxs-lookup"><span data-stu-id="81977-323">*Available capacity for a capability = Capacity for the capability &ndash; Job scheduled load on the resources with the specific capability, included in the resource group &ndash; Operations scheduled load on the resources with the specific capability, included in the resource group &ndash; Operations scheduled load on the resource group itself that require the specific capability*</span></span>

<span data-ttu-id="81977-324">Det betyder, at hvis der er belastning på en bestemt ressource, tages der højde for belastningen i beregningen af ressourcegruppens ledige kapacitet pr. egenskab, fordi belastningen på en bestemt ressource reducerer dens bidrag til ressourcegruppens kapacitet for en egenskab, uanset om belastningen på den specifikke ressource er for den pågældende egenskab.</span><span class="sxs-lookup"><span data-stu-id="81977-324">This means that if there is load on a specific resource, the load is considered in the calculation of the resource group's available capacity per capability, because the load on a specific resource reduces its contribution to the resource group's capacity for a capability no matter if the load on the specific resource is for that specific capability.</span></span> <span data-ttu-id="81977-325">Hvis der er belastning på ressourcegruppeniveauet, medtages den kun i beregningen af ressourcegruppens ledige kapacitet pr. egenskab, hvis belastningen er fra en operation, der kræver den specifikke egenskab.</span><span class="sxs-lookup"><span data-stu-id="81977-325">If there is load on the resource group level, it is considered in the calculation of the resource group's available capacity per capability only if the load is from an operation that requires the specific capability.</span></span>

<span data-ttu-id="81977-326">Ovenstående logik er kompliceret, da det er den samme for hver type "egenskab", så hvis du bruger en grovplanlægning med begrænset kapacitet, kræver det en stor mængde data, der skal indlæses.</span><span class="sxs-lookup"><span data-stu-id="81977-326">The above logic is complicated, as this is the same for each type of "property" so using operations scheduling with finite capacity requires a significant amount of data to be loaded.</span></span>

## <a name="viewing-scheduling-engine-input-and-output"></a><span data-ttu-id="81977-327">Visning af input og output for planlægningsprogrammet</span><span class="sxs-lookup"><span data-stu-id="81977-327">Viewing scheduling engine input and output</span></span>

<span data-ttu-id="81977-328">Hvis du vil have specifikke detaljer om input og output for planlægningsprocessen, skal du aktivere logføring ved at gå til **Organisationsadministrations \> Konfiguration \> Planlægning \> Planlægning af sporing af cockpit**.</span><span class="sxs-lookup"><span data-stu-id="81977-328">To get specific details of the input and output of the scheduling process,  enable logging by going to **Organization administration \> Setup \> Scheduling \> Scheduling tracing cockpit**.</span></span>

<span data-ttu-id="81977-329">På denne side skal du først vælge **Aktivér logføring** i handlingsruden.</span><span class="sxs-lookup"><span data-stu-id="81977-329">On this page, first select **Enable logging** on the Action Pane.</span></span> <span data-ttu-id="81977-330">Kør derefter planlægningen for produktionsordren.</span><span class="sxs-lookup"><span data-stu-id="81977-330">Then run the scheduling for the production order.</span></span> <span data-ttu-id="81977-331">Når den er færdig, skal du vende tilbage til siden **Planlægning af sporing af cockpit** og vælge **Deaktiver logføring** i handlingsruden.</span><span class="sxs-lookup"><span data-stu-id="81977-331">When complete, return to the **Scheduling tracing cockpit** page and select **Disable logging** on the Action Pane.</span></span> <span data-ttu-id="81977-332">Opdater siden, hvorefter der vises en ny linje i gitteret.</span><span class="sxs-lookup"><span data-stu-id="81977-332">Refresh the page and a new line will appear in the grid.</span></span> <span data-ttu-id="81977-333">Vælg den nye linje, og vælg **Download** i handlingsruden.</span><span class="sxs-lookup"><span data-stu-id="81977-333">Select the new line and select **Download** on the Action Pane.</span></span> <span data-ttu-id="81977-334">Dette giver dig en .zip-komprimeret mappe, der indeholder følgende filer:</span><span class="sxs-lookup"><span data-stu-id="81977-334">This will give you a .zip compressed folder containing the following files:</span></span>

- <span data-ttu-id="81977-335">**Log.txt** - Dette er den logfil, der beskriver de trin, som programmet gennemgår.</span><span class="sxs-lookup"><span data-stu-id="81977-335">**Log.txt** - This is the log file that describes the steps that the engine goes through.</span></span> <span data-ttu-id="81977-336">Det er meget avanceret og kan være en smule overvældende, men når den bruges som led i at eksperimentere med ruteopsætningen for at løse problemer med ydeevnen, er det første, du skal se efter, forskellen i tiden mellem den første og den sidste linje, som giver dig den nøjagtige tid, du har brugt til planlægningen.</span><span class="sxs-lookup"><span data-stu-id="81977-336">It is very elaborate and can be a bit overwhelming, but when used as part of experimenting with the route setup to resolve performance problems the first thing to look for is the difference in time between the first and the last line, as this will give you the exact time the scheduler has spent.</span></span>
- <span data-ttu-id="81977-337">**XmlModel.xml** - Den indeholder den model, der er indbygget i X++, og som programmet kører på.</span><span class="sxs-lookup"><span data-stu-id="81977-337">**XmlModel.xml** - This contains the model that is built in X++ and that the engine operates on.</span></span> <span data-ttu-id="81977-338">Det `JobId`, der bruges i filen, svarer til `RecId` fra den kildetabel, der indeholder jobbene (`ReqRouteJob` eller `ProdRouteJob`).</span><span class="sxs-lookup"><span data-stu-id="81977-338">The `JobId` used in the file correlates to the `RecId` from the source table containing the jobs (`ReqRouteJob` or `ProdRouteJob`).</span></span> <span data-ttu-id="81977-339">Du skal typisk i denne fil se efter, om de datoer, der er angivet i `ConstraintJobStartsAt` og `ConstraintJobEndsAt`, er som forventet, at `JobGoal`-egenskaben er angivet korrekt, og at jobbene er relateret til hinanden via `JobLink`-begrænsningerne.</span><span class="sxs-lookup"><span data-stu-id="81977-339">The typical thing to look for in this file is that the dates given in `ConstraintJobStartsAt` and `ConstraintJobEndsAt` are as expected, that the `JobGoal` property is set correctly, and that the jobs are related to each other through the `JobLink` constraints.</span></span>
- <span data-ttu-id="81977-340">**XmlSlots.xml** - Den indeholder alle de arbejdstider og kapacitetsreservationer, som programmet har anmodet om.</span><span class="sxs-lookup"><span data-stu-id="81977-340">**XmlSlots.xml** - This contains all the working times and capacity reservations that the engine has requested.</span></span> <span data-ttu-id="81977-341">Kalenderens arbejdstider og reservationer anmodes kun af programmet for de tidsperioder, hvor der gøres forsøg på at placere jobbene (og en ekstra buffer), så hvis filen indeholder tider langt ude i fremtiden, kan det være en indikation på et problem med konfigurationen.</span><span class="sxs-lookup"><span data-stu-id="81977-341">The calendar working times and reservations will only be requested by the engine for the time periods where it tries to place the jobs (and an extra buffer), so if the file contains times very far in the future, it might be an indication of a problem with the setup.</span></span> <span data-ttu-id="81977-342">`ResourceProperty`-noderne vises for hver ressource, som ressourcegruppen og egenskaberne er tilknyttet, og for hvilke perioder.</span><span class="sxs-lookup"><span data-stu-id="81977-342">The `ResourceProperty` nodes will show for each resource which resource group and capabilities it is associated with for which periods.</span></span>
- <span data-ttu-id="81977-343">**Result.xml** - Den indeholder resultatet af planlægningskørslen.</span><span class="sxs-lookup"><span data-stu-id="81977-343">**Result.xml** - This contains the result of the scheduling run.</span></span>

<span data-ttu-id="81977-344">Bemærk, at sporingsfunktionen kan give et betydeligt forbrug af ydeevne, så brug den kun til at undersøge planlægningen af specifikke ordrer på en kontrolleret måde.</span><span class="sxs-lookup"><span data-stu-id="81977-344">Note that the tracing functionality can add significant performance overhead, so only use it for investigating scheduling of specific orders in a controlled manner.</span></span> <span data-ttu-id="81977-345">Hvis den er aktiveret under en varedisponeringskørsel, vil den hurtigt nå størrelsesgrænsen og stoppe.</span><span class="sxs-lookup"><span data-stu-id="81977-345">If it is turned on during a master planning run it will quickly reach its size limit and stop.</span></span>

## <a name="troubleshooting-performance"></a><span data-ttu-id="81977-346">Fejlfinding af ydeevne</span><span class="sxs-lookup"><span data-stu-id="81977-346">Troubleshooting performance</span></span>

<span data-ttu-id="81977-347">Som det fremgår af alle tidligere afsnit, er der nogle faldgruber, når det kommer til opsætning og brug af planlægningsprogrammet, hvilket kan medføre problemer med ydeevnen.</span><span class="sxs-lookup"><span data-stu-id="81977-347">As can be understood from all of the previous sections, there are some pitfalls when it comes to the setup and usage of the scheduling engine, which can lead to performance problems.</span></span> <span data-ttu-id="81977-348">Følgende kontrolliste kan bruges til fejlfinding af sådanne problemer.</span><span class="sxs-lookup"><span data-stu-id="81977-348">The following check list can be used for troubleshooting such issues.</span></span> <span data-ttu-id="81977-349">Det er vigtigt at kigge på alle punkter, da det ofte er en kombination af flere faktorer, der fører til problemer.</span><span class="sxs-lookup"><span data-stu-id="81977-349">It is important to look at all the points as it is most often a combination of multiple factors that leads to problems.</span></span>

### <a name="performing-scheduling-as-part-of-mrp-when-it-is-not-needed"></a><span data-ttu-id="81977-350">Planlægning, der udføres som del af MRP, når det ikke er nødvendigt</span><span class="sxs-lookup"><span data-stu-id="81977-350">Performing scheduling as part of MRP when it is not needed</span></span>

<span data-ttu-id="81977-351">Selvom der bruges ruter til produktionskontrolformål, f.eks. efterkalkulation og rapportering, er det muligvis ikke nødvendigt at overveje dem under MRP.</span><span class="sxs-lookup"><span data-stu-id="81977-351">Even though routes are used for the production control purposes such as costing and reporting, it might not be necessary to consider them during MRP.</span></span> <span data-ttu-id="81977-352">I nogle tilfælde vil en standardproduktionsgennemløbstid for varen være tilstrækkelig til planlægningen.</span><span class="sxs-lookup"><span data-stu-id="81977-352">In some cases, having a standard production lead time specified for the item will be sufficient for planning.</span></span> <span data-ttu-id="81977-353">Hvis du vil deaktivere ruteplanlægning, skal du angive kapacitetstidshorisonten til nul.</span><span class="sxs-lookup"><span data-stu-id="81977-353">To turn off route scheduling, set the capacity time fence to zero.</span></span> <span data-ttu-id="81977-354">Hvis planlægningen skal foretages, skal kapacitetshorisonten angives omhyggeligt, da det muligvis ikke er nødvendigt at overveje ruter for hele MPS-disponeringstidshorisonten.</span><span class="sxs-lookup"><span data-stu-id="81977-354">If scheduling should be done, then the capacity time fence must be carefully set because it might not be necessary to consider routes for the full extent of the MRP's coverage time fence.</span></span>

<span data-ttu-id="81977-355">Bemærk, at hvis ordren ikke planlægges under MPS, skal den i stedet planlægges, når ordreforslaget autoriseres.</span><span class="sxs-lookup"><span data-stu-id="81977-355">Note that if the order is not scheduled during MRP, then it will instead need to be scheduled when the planned order is firmed.</span></span> <span data-ttu-id="81977-356">Det betyder, at autorisationsprocessen tager længere tid, så afhængigt af, hvor mange af de foreslåede ordreforslag der får den autoriserede ydeevnegevinst i MRP, kan den gå tabt ved autorisation.</span><span class="sxs-lookup"><span data-stu-id="81977-356">This means that the firming process will take longer, so depending on how many of the suggested planned orders get firmed the performance gain during MRP might be lost at firming.</span></span>

### <a name="route-with-unnecessary-operations"></a><span data-ttu-id="81977-357">Rute med unødvendige handlinger</span><span class="sxs-lookup"><span data-stu-id="81977-357">Route with unnecessary operations</span></span>

<span data-ttu-id="81977-358">Når du designer ruten, er det fristende at prøve at modellere den virkelige verden nøjagtigt med alle de trin, som produktionen gennemgår.</span><span class="sxs-lookup"><span data-stu-id="81977-358">When designing the route, it is tempting to try to model the real world exactly with all the steps the production goes through.</span></span> <span data-ttu-id="81977-359">Dette kan være nyttigt i nogle tilfælde, men det er ikke godt for ydeevnen, da den model, som programmet skal arbejde på, bliver større (både hvad angår job og begrænsninger), og der vil blive udført flere SQL-sætninger for indsætning og opdatering af job og kapacitetsreservationer.</span><span class="sxs-lookup"><span data-stu-id="81977-359">While this can be useful in some cases, it is not good for the performance as the model the engine needs to work on gets larger (both in terms of jobs and constraints) and more SQL statements will be executed for insertion and update of the jobs and capacity reservations.</span></span> <span data-ttu-id="81977-360">Der er desuden en downstream-effekt, hvor det er nødvendigt at rapportere fremskridt på jobbene, hvilket kan afhjælpes med automatiske posteringer.</span><span class="sxs-lookup"><span data-stu-id="81977-360">Also, there is the downstream effect of having to eventually report progress on the jobs, which can be mitigated with automatic postings.</span></span> <span data-ttu-id="81977-361">Hvis dataene ikke bruges til noget, oprettes der en unødvendig belastning.</span><span class="sxs-lookup"><span data-stu-id="81977-361">If the data is not used for anything, it creates unnecessary load.</span></span>

<span data-ttu-id="81977-362">Det anbefales, at du kun opretter operationer, der er strengt nødvendige for planlægning (som typisk vil være flaskehalsressourcer) og/eller efterkalkulationsformål.</span><span class="sxs-lookup"><span data-stu-id="81977-362">We recommend that you only create operations that are strictly needed for scheduling (which will typically be the bottleneck resources) and/or costing purposes.</span></span> <span data-ttu-id="81977-363">Alternativt kan du gruppere mange mindre handlinger i én større handling, der repræsenterer en større del af processen.</span><span class="sxs-lookup"><span data-stu-id="81977-363">Alternatively you should group many smaller distinct operations into one larger operation that represents a greater part of the process.</span></span>

### <a name="many-applicable-resources-for-an-operation"></a><span data-ttu-id="81977-364">Operation med mange relevante ressourcer</span><span class="sxs-lookup"><span data-stu-id="81977-364">Many applicable resources for an operation</span></span>

<span data-ttu-id="81977-365">Antallet af relevante ressourcer til en operation bestemmes af de ressourcekrav, der er angivet for operationsrelationen.</span><span class="sxs-lookup"><span data-stu-id="81977-365">The number of applicable resources for an operation is determined by the resource requirements set on the operation relation.</span></span> <span data-ttu-id="81977-366">Kravet kan enten være til en bestemt ressource (individuel), eller det kan være baseret på ressourcens medlemskab af en ressourcegruppe eller egenskab.</span><span class="sxs-lookup"><span data-stu-id="81977-366">The requirement can either be for a specific (individual) resource or it can be based on the resource's membership of a resource group or capability.</span></span>

<span data-ttu-id="81977-367">Hvis der ikke foretages planlægning ved hjælp af kapacitetsbegrænsning, og alle de relevante ressourcer har samme kalender og effektivitet, vil planlægningsprogrammet altid ende med at vælge den samme ressource for en operation, men kun efter at have forsøgt alle de relevante ressourcer for at kontrollere, om der er en "bedre" end de andre.</span><span class="sxs-lookup"><span data-stu-id="81977-367">If scheduling is not done using finite capacity and all the applicable resources have the same calendar and efficiency, then the scheduling engine will always end up picking the same resource for an operation, but only after trying all the applicable resources to check if there is one that is "better" than the others.</span></span> <span data-ttu-id="81977-368">I dette tilfælde kan belastningen af planlægningen reduceres væsentligt ved ganske enkelt at tildele en bestemt ressource til operationen på rutedesigntidspunktet.</span><span class="sxs-lookup"><span data-stu-id="81977-368">In this case, the load of the scheduling can be greatly reduced simply by always assigning a specific resource to the operation at the route design time.</span></span>

### <a name="route-with-parallel-operations"></a><span data-ttu-id="81977-369">Rute med parallelle handlinger</span><span class="sxs-lookup"><span data-stu-id="81977-369">Route with parallel operations</span></span>

<span data-ttu-id="81977-370">Parallelle operationer (primær/sekundær) er et effektivt værktøj til modelscenarier, som f.eks. når en maskine og en operatør begge er nødvendige for at udføre en bestemt opgave, med er også kilden til mange problemer med ydeevnen.</span><span class="sxs-lookup"><span data-stu-id="81977-370">While parallel operations (primary/secondary) are a powerful tool to model scenarios like when a machine and an operator are both needed to perform a specific task, it is also the source of many performance issues.</span></span> <span data-ttu-id="81977-371">Hvis et krav om en bestemt individuel ressource er tildelt både den primære og den sekundære operation, er det normalt ikke et problem.</span><span class="sxs-lookup"><span data-stu-id="81977-371">If a requirement for a specific individual resource is assigned to both the primary and secondary operation, it is typically not a problem.</span></span> <span data-ttu-id="81977-372">Men hvis der er mange mulige ressourcer for hver af operationerne, føjer den betydelig beregningskompleksitet til planlægningen.</span><span class="sxs-lookup"><span data-stu-id="81977-372">But if there are many possible resources for each of the operations, then it adds significant computational complexity to the scheduling.</span></span>

<span data-ttu-id="81977-373">Et alternativ til at bruge parallelle operationer er enten at udforme parrene som "virtuelle" ressourcer (hvilket derefter vil repræsentere det team, der altid samles for operationen) eller blot at modellere en af operationerne, hvis den ikke udgør en flaskehals.</span><span class="sxs-lookup"><span data-stu-id="81977-373">An alternative to using parallel operations is either to model the pairs as "virtual" resources (which will then represent the team that always goes together for the operation) or to simply not model one of the operations if it doesn't represent a bottleneck.</span></span>

### <a name="route-with-quantity-of-resources-higher-than-1"></a><span data-ttu-id="81977-374">Rute med et antal ressourcer, der er større end 1</span><span class="sxs-lookup"><span data-stu-id="81977-374">Route with quantity of resources higher than 1</span></span>

<span data-ttu-id="81977-375">Hvis du angiver det antal ressourcer, der skal bruges til en operation, til over ét, giver det i praksis de samme primære/sekundære operationer, da der sendes flere parallelle job til programmet.</span><span class="sxs-lookup"><span data-stu-id="81977-375">If setting the quantity of resources needed for an operation higher than one, then it results effectively the same as using primary/secondary operations because multiple parallel jobs are sent to the engine.</span></span> <span data-ttu-id="81977-376">I dette tilfælde er der dog ikke mulighed for at bruge bestemte ressourcetildelinger, da et større antal end ét kræver, at mere end én ressource kan anvendes til operationen.</span><span class="sxs-lookup"><span data-stu-id="81977-376">However, for this case there is not an option of using specific resource assignments, because a quantity higher than one requires that more than one resource is applicable for the operation.</span></span>

### <a name="excessive-use-of-finite-capacity"></a><span data-ttu-id="81977-377">Overdreven brug af kapacitetsbegrænsning</span><span class="sxs-lookup"><span data-stu-id="81977-377">Excessive use of finite capacity</span></span>

<span data-ttu-id="81977-378">Brug af kapacitetsbegrænsning kræver, at programmet indlæser kapacitetsoplysningerne fra en database og kan have et beregningsoverskud, da det vil være sværere at finde en løsning, især i miljøer, hvor ressourcerne er reserveret tæt på den maksimale kapacitet.</span><span class="sxs-lookup"><span data-stu-id="81977-378">Use of finite capacity requires the engine to load the capacity information from a database and can have a computational overhead because it will be harder to find a solution especially in environments where the resources are booked close to their maximum capacity.</span></span> <span data-ttu-id="81977-379">Derfor er det vigtigt at vurdere, om en ressource virkelig har brug for kapacitetsbegrænsning, eller den kan overbookes.</span><span class="sxs-lookup"><span data-stu-id="81977-379">As a result, it is important to carefully evaluate if a resource really needs to use finite capacity or they can be overbooked.</span></span> <span data-ttu-id="81977-380">Da der kan være forskel på kapacitetsbegrænsninger for ressourcerne på, hvor vigtigt det er, at de ikke er overbooket, anbefales det, at du bruger flaskehalsindstillingen i en ressource kombineret med en separat værdi i planen "Kapacitetstidshorisont for flaskehalsressourcer".</span><span class="sxs-lookup"><span data-stu-id="81977-380">Because there might be a difference among finite capacity resources in how important they are not to overbook, we recommend using the bottleneck option on a resource in combination with a separate value on the plan in "Capacity time fence for bottleneck resources".</span></span> <span data-ttu-id="81977-381">Ved at bruge flaskehalse kan du sikre, at den generelle tidshorisont for kapacitetsbegrænsning kan sænkes.</span><span class="sxs-lookup"><span data-stu-id="81977-381">Using the bottleneck concept can enable that the general finite capacity time fence can be lowered.</span></span>

### <a name="setting-hard-links"></a><span data-ttu-id="81977-382">Indstilling af hårde links</span><span class="sxs-lookup"><span data-stu-id="81977-382">Setting hard links</span></span>

<span data-ttu-id="81977-383">Rutens standardlinktype er *blød*, hvilket betyder, at der tillades et tidsinterval mellem sluttidspunktet for en operation og starten af den næste.</span><span class="sxs-lookup"><span data-stu-id="81977-383">The standard link type of the route is *soft*, which means that a time gap is allowed between the finishing time of one operation and the start of the next.</span></span> <span data-ttu-id="81977-384">Hvis du tillader dette, kan det have den uheldige virkning at, hvis der ikke er materialer eller kapacitet til rådighed for en af operationerne i meget lang tid, så kan produktionen være inaktiv i et langt tidsrum, hvilket vil sige en mulig forøgelse af igangværende arbejde.</span><span class="sxs-lookup"><span data-stu-id="81977-384">Allowing this can have the unfortunate effect that, if materials or capacity are not available for one of the operations for a very long time, the production could be idle for quite a while, meaning a possible increase of work in progress.</span></span> <span data-ttu-id="81977-385">Dette sker ikke med hårde links, fordi afslutningen og starten skal justeres perfekt.</span><span class="sxs-lookup"><span data-stu-id="81977-385">This will not happen with hard links because the finish and start must align perfectly.</span></span> <span data-ttu-id="81977-386">Men hvis der angives hårde links, bliver planlægningsproblemet vanskeligere, fordi der skal beregnes arbejdstid og kapacitetsskæringspunkter for de to ressourcer til operationerne.</span><span class="sxs-lookup"><span data-stu-id="81977-386">But setting hard links makes the scheduling problem more difficult because working time and capacity intersections must be calculated for the two resources of the operations.</span></span> <span data-ttu-id="81977-387">Hvis der også er parallelle operationer, tilføjer dette betydelig beregningstid.</span><span class="sxs-lookup"><span data-stu-id="81977-387">If there are also parallel operations involved, this adds significant computational time.</span></span> <span data-ttu-id="81977-388">Hvis ressourcerne i de to operationer har forskellige kalendere, der slet ikke overlapper, er problemet uløseligt.</span><span class="sxs-lookup"><span data-stu-id="81977-388">If the resources of the two operations have different calendars that don't overlap at all, the problem is unsolvable.</span></span>

<span data-ttu-id="81977-389">Det anbefales, at du kun bruger hårde links, når det er strengt nødvendigt, og nøje overvejer, om det er nødvendigt for hver operation i ruten.</span><span class="sxs-lookup"><span data-stu-id="81977-389">We recommend using hard links only when strictly necessary, and carefully consider if it is necessary for each operation of the route.</span></span>

<span data-ttu-id="81977-390">Hvis du vil reducere det igangværende arbejde uden at anvende hårde links, er det en fordel at planlægge ordren to gange med skifte til den modsatte retning for det andet gennemløb.</span><span class="sxs-lookup"><span data-stu-id="81977-390">To reduce the work in progress without applying hard links, a trick is to schedule the order twice with changing to the opposite direction for the second pass.</span></span> <span data-ttu-id="81977-391">Hvis den første plan blev udført bagud fra leveringsdatoen, skal den anden ske fremad fra den planlagte startdato.</span><span class="sxs-lookup"><span data-stu-id="81977-391">If the first schedule was done backwards from delivery date, then the second should be done forward from the scheduled start date.</span></span> <span data-ttu-id="81977-392">Det vil resultere i, at jobbene komprimeres så meget som muligt, så igangværende arbejde minimeres.</span><span class="sxs-lookup"><span data-stu-id="81977-392">This will result in the jobs being compressed as much as possible so that the work in progress is minimized.</span></span>

### <a name="separate-calendar-for-each-resource"></a><span data-ttu-id="81977-393">Separat kalender for hver ressource</span><span class="sxs-lookup"><span data-stu-id="81977-393">Separate calendar for each resource</span></span>

<span data-ttu-id="81977-394">En af de vigtigste datakilder for planlægningsprogrammet er kalenderoplysninger, som kan være kostbare at indlæse fra databasen.</span><span class="sxs-lookup"><span data-stu-id="81977-394">One of the main sources of data for the scheduling engine is calendar information, which can be expensive to load from the database.</span></span> <span data-ttu-id="81977-395">Da der genereres kalendere på basis af skabeloner, vil det være fristende at generere en kalender for hver ressource og derefter justere oplysningerne i denne kalender, når ressourcen har nedetid og andre problemer.</span><span class="sxs-lookup"><span data-stu-id="81977-395">Because calendars are generated based on templates, it would be tempting to generate a calendar for each resource and then adjust the information in this calendar when the resource has downtime and other issues.</span></span> <span data-ttu-id="81977-396">Hvis du gør dette, vil det dog begrænse programmets mulighed for at cachelagre kalenderdataene, da det ville være nødvendigt at anmode om nye data for hver ressource, og det kan være en stor kilde til problemer med ydeevnen.</span><span class="sxs-lookup"><span data-stu-id="81977-396">However, doing this will severely limit the engines ability to cache the calendar data as it would need to request new data for each resource and can be a large source of performance problems.</span></span> <span data-ttu-id="81977-397">Vi anbefaler i stedet, at du genbruger kalenderne så meget som muligt mellem ressourcerne og derefter styrer ændringerne af nedetiden ved at tildele et andet kalender-id for en periode.</span><span class="sxs-lookup"><span data-stu-id="81977-397">Instead, we recommend that you reuse the calendars as much as possible between the resources, and then control downtime changes by assigning a different calendar ID for a period.</span></span>

### <a name="high-number-of-working-time-slots-per-calendar-day"></a><span data-ttu-id="81977-398">Højt antal arbejdstidsrubrikker pr. dag i kalenderen</span><span class="sxs-lookup"><span data-stu-id="81977-398">High number of working time slots per calendar day</span></span>

<span data-ttu-id="81977-399">Da programmet fungerer ved at undersøge tidsrubrikkers kapacitet én for én, er det en fordel at minimere antallet af tidsrubrikker pr. kalenderdag.</span><span class="sxs-lookup"><span data-stu-id="81977-399">Because the engine works by examining time slots one-by-one for capacity, it is beneficial to minimize the number of time slots per calendar day.</span></span> <span data-ttu-id="81977-400">Dette kan f.eks. ske ved at overveje, om det er vigtigt for tidsplanen at afspejle, at arbejderne har en pause på 5 minutter hver time.</span><span class="sxs-lookup"><span data-stu-id="81977-400">This could be done, for example, by considering whether it's important for the resulting schedule to reflect that workers have a 5-minute break every hour.</span></span>

### <a name="large-or-none-scheduling-timeouts"></a><span data-ttu-id="81977-401">Store (eller ingen) planlægningstimeout</span><span class="sxs-lookup"><span data-stu-id="81977-401">Large (or none) scheduling timeouts</span></span>

<span data-ttu-id="81977-402">Planlægningsprogrammets ydeevne kan optimeres ved hjælp af parametre, der findes på siden **Planlægningsparametre**.</span><span class="sxs-lookup"><span data-stu-id="81977-402">Scheduling engine performance can be optimized using parameters found on the **Scheduling parameters** page.</span></span> <span data-ttu-id="81977-403">Indstillingerne **Timeout for planlægning er aktiveret** og **Timeout for planlægningsoptimering er aktiveret** skal altid angives til **Ja**.</span><span class="sxs-lookup"><span data-stu-id="81977-403">The **Scheduling timeout enabled** and **Scheduling optimization timeout enabled** settings should always be set to **Yes**.</span></span> <span data-ttu-id="81977-404">Hvis angivet til **Nej**, kan planlægningen muligvis løbe uendeligt, hvis der er oprettet en umulig rute med mange indstillinger.</span><span class="sxs-lookup"><span data-stu-id="81977-404">If set to **No**, the scheduling can potentially run infinitely if an unfeasible route with many options has been created.</span></span>

<span data-ttu-id="81977-405">Værdien for **Maksimal planlægningstid pr. sekvens** styrer, hvor mange sekunder der højst må bruges på at forsøge at finde en løsning for en enkelt sekvens (i de fleste tilfælde svarer en sekvens til en enkelt ordre).</span><span class="sxs-lookup"><span data-stu-id="81977-405">The value for **Maximum scheduling time per sequence** controls how many seconds can, at most, be spent trying to find a solution for a single sequence (in most cases a sequence corresponds to a single order).</span></span> <span data-ttu-id="81977-406">Den værdi, der skal bruges her, afhænger af kompleksiteten af ruten og indstillinger som kapacitetsbegrænsning, og maksimalt ca. 30 sekunder er et godt udgangspunkt.</span><span class="sxs-lookup"><span data-stu-id="81977-406">The value to use here highly depends on the complexity of the route and settings like finite capacity, ut a maximum of about 30 seconds is a good starting point.</span></span>

<span data-ttu-id="81977-407">Værdien for **Timeout for optimeringsforsøg** styrer, hvor mange sekunder der højst må bruges på at finde en bedre løsning end den, der oprindeligt blev fundet.</span><span class="sxs-lookup"><span data-stu-id="81977-407">The value for **Optimization attempts timeout** controls how many seconds can at most be used to find a better solution than the one originally found.</span></span> <span data-ttu-id="81977-408">Dette vil kun påvirke ruter, der bruger parallelle operationer, da disse gør det nødvendigt at teste forskellige kombinationer.</span><span class="sxs-lookup"><span data-stu-id="81977-408">This will only influence routes that are using parallel operations as these make it necessary to test different combinations.</span></span>

> [!NOTE]
> <span data-ttu-id="81977-409">De værdier, der er angivet for timeout, anvendes både til planlægning af frigivne produktionsordrer og ordreforslag som en del af MRP.</span><span class="sxs-lookup"><span data-stu-id="81977-409">The values set for the timeouts will be applied both for scheduling of released production orders and of planned orders as part of MRP.</span></span> <span data-ttu-id="81977-410">Derfor kan angivelse af meget høje værdier betyde markant længere kørselstid for MRP, når der køres for en plan med mange produktionsordreforslag.</span><span class="sxs-lookup"><span data-stu-id="81977-410">As a result, setting very high values could significantly add to the run time of MRP when running for a plan with many planned production orders.</span></span>


[!INCLUDE[footer-include](../../includes/footer-banner.md)]